# -*- coding: utf-8 -*-
"""hw5p7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QGuX2ghSo10PQjvw0vTX2rYJBtniomae
"""

import numpy as np
import math
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

L_1 = L_2 = L_3 = 1

theta_1 = [-math.pi] * 1000
counter_1 = 0
iter_1 = 0
theta_2 = [-math.pi] * 1000
counter_2 = 0
iter_2 = 0
theta_3 = [-math.pi] * 1000
counter_3 = 0

for i in range(len(theta_3)):
  if counter_3 == 10:
    counter_3 = 0
  theta_3[i] = theta_3[i] + counter_3*(2*math.pi/10)
  counter_3 += 1

for i in range(len(theta_2)):
  if counter_2 == 10:
    counter_2 = 0
    iter_2 += 1
  if iter_2 == 10:
    iter_2 = 0
  theta_2[i] = theta_2[i] + iter_2*(2*math.pi/10)
  counter_2 += 1

for i in range(len(theta_1)):
  if counter_1 == 100:
    counter_1 = 0
    iter_1 += 1
  theta_1[i] = theta_1[i] + iter_1*(2*math.pi/10)
  counter_1 += 1

input_array = np.array([theta_1, theta_2, theta_3])
input_array = input_array.T
np.random.shuffle(input_array)
print(input_array)

def forward_kinematics(theta_1, theta_2, theta_3):
  t_00 = math.cos(theta_1) * math.cos(theta_2 + theta_3)
  t_01 = -math.cos(theta_1) * math.sin(theta_2 + theta_3)
  t_02 = -math.sin(theta_1)
  t_03 = math.cos(theta_1) * math.cos(theta_2 + theta_3) * L_3 + \
  math.cos(theta_1) * math.cos(theta_2) * L_2 + math.cos(theta_1) * L_1
  t_10 = math.sin(theta_1) * math.cos(theta_2 + theta_3)
  t_11 = -math.sin(theta_1) * math.sin(theta_2 + theta_3)
  t_12 = math.cos(theta_1)
  t_13 = math.sin(theta_1) * math.cos(theta_2 + theta_3) * L_3 + \
  math.sin(theta_1) * math.cos(theta_2) * L_2 + math.sin(theta_1) * L_1
  t_20 = -math.sin(theta_2 + theta_3)
  t_21 = -math.cos(theta_2 + theta_3)
  t_22 = 0
  t_23 = -math.sin(theta_2 + theta_3) * L_3 - math.sin(theta_2) * L_2
  t_30 = 0
  t_31 = 0
  t_32 = 0
  t_33 = 1
  transformation = np.array([[t_00, t_01, t_02, t_03], [t_10, t_11, t_12, t_13],\
                            [t_20, t_21, t_22, t_23], [t_30, t_31, t_32, t_33]])
  o_d = transformation[:, [3]]
  o_d = o_d[:-1]
  return o_d.T

def generate_output(config):
    length = len(config)
    traj = np.zeros(shape=(length,3))
    for i in range(length):
        traj[i] = forward_kinematics(config[i][0], config[i][1], config[i][2])
    return traj

y_train = input_array[:800]
y_test = input_array[800:]
x_train = generate_output(y_train)
x_test = generate_output(y_test)

model = tf.keras.models.Sequential([
  tf.keras.layers.Dense(3),
  tf.keras.layers.Dense(64, activation="relu"),
  tf.keras.layers.Dense(3)
])

model.compile(optimizer='adam',
              loss="mse",
              metrics=['accuracy'])

history = model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=1000)

def plot(history):
  
  acc = history.history['accuracy']
  val_acc = history.history['val_accuracy']
  loss = history.history['loss']
  val_loss = history.history['val_loss']

  epochs = range(len(acc))

  plt.title('Training and validation accuracy')
  plt.plot(epochs, acc, color='blue', label='Train')
  plt.plot(epochs, val_acc, color='orange', label='Val')
  plt.xlabel('Epoch')
  plt.ylabel('Accuracy')
  plt.legend()

  _ = plt.figure()
  plt.title('Training and validation loss')
  plt.plot(epochs, loss, color='blue', label='Train')
  plt.plot(epochs, val_loss, color='orange', label='Val')
  plt.xlabel('Epoch')
  plt.ylabel('Loss')
  plt.legend()
  
plot(history)

K = 500
traj = np.zeros((K,3))
traj[:,0] = 2*np.cos(np.linspace(0,2*np.pi,num=K))
traj[:,1] = 2*np.sin(np.linspace(0,2*np.pi,num=K))
traj[:,2] = np.sin(np.linspace(0,8*np.pi,num=K))

ax = plt.axes(projection='3d')
ax.plot3D(traj[:,0], traj[:,1], traj[:,2])

predictions = model.predict(traj)

predicted_traj = generate_output(predictions)

ax = plt.axes(projection='3d')
ax.plot3D(predicted_traj[:,0], predicted_traj[:,1], predicted_traj[:,2])

def plot_joint_config(traj):
  plt.plot(traj[:,0], label='theta_1')
  plt.plot(traj[:,1], label='theta_2')
  plt.plot(traj[:,2], label='theta_3')
  plt.xlabel('K')
  plt.ylabel('theta')
  plt.legend()

plot_joint_config(predictions)