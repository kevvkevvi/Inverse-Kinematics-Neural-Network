# -*- coding: utf-8 -*-
"""hw5p6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PcAErf6OB3TfCS2xvHtF0kJcQFE8_OKV
"""

import time
def measure_time():
    def wraps(func):
        def mesure(*args,**kwargs):
            start = time.time()
            res = func(*args,**kwargs)
            end = time.time()
            # logger.info("function %s use time %s"%(func.__name__,(end-start)))
            print("function %s use time %s"%(func.__name__,(end-start)))
            return res
        return mesure
    return wraps

"""
COMS 4733:
"""
import numpy as np
import math

L_1 = L_2 = L_3 = 1
alpha = 0.01
lambda_sq = 0.01
t_d = np.array([[0.078, -0.494, 0.866, 1], [0.135, -0.855, -0.500, 2], \
                [0.988, 0.156, 0, 2], [0, 0, 0, 1]])
x_d = np.array([[0.078], [0.135], [0.988]])
y_d = np.array([[-0.494], [-0.855], [0.156]])
z_d = np.array([[0.866], [-0.500], [0]])
o_d = np.array([[1], [2], [2]])

def forward_kinematics(theta_1, theta_2, theta_3):
  t_00 = math.cos(theta_1) * math.cos(theta_2 + theta_3)
  t_01 = -math.cos(theta_1) * math.sin(theta_2 + theta_3)
  t_02 = -math.sin(theta_1)
  t_03 = math.cos(theta_1) * math.cos(theta_2 + theta_3) * L_3 + \
  math.cos(theta_1) * math.cos(theta_2) * L_2 + math.cos(theta_1) * L_1
  t_10 = math.sin(theta_1) * math.cos(theta_2 + theta_3)
  t_11 = -math.sin(theta_1) * math.sin(theta_2 + theta_3)
  t_12 = math.cos(theta_1)
  t_13 = math.sin(theta_1) * math.cos(theta_2 + theta_3) * L_3 + \
  math.sin(theta_1) * math.cos(theta_2) * L_2 + math.sin(theta_1) * L_1
  t_20 = -math.sin(theta_2 + theta_3)
  t_21 = -math.cos(theta_2 + theta_3)
  t_22 = 0
  t_23 = -math.sin(theta_2 + theta_3) * L_3 - math.sin(theta_2) * L_2
  t_30 = 0
  t_31 = 0
  t_32 = 0
  t_33 = 1
  transformation = np.array([[t_00, t_01, t_02, t_03], [t_10, t_11, t_12, t_13],\
                            [t_20, t_21, t_22, t_23], [t_30, t_31, t_32, t_33]])
  return transformation


def jacobian(theta_1, theta_2, theta_3):
  j_00 = -math.sin(theta_1) * (math.cos(theta_2 + theta_3) * L_3 + \
                               math.cos(theta_2) * L_2 + L_1)
  j_01 = -math.cos(theta_1) * (math.sin(theta_2 + theta_3) * L_3 + \
                               math.sin(theta_2) * L_2)
  j_02 = -math.cos(theta_1) * math.sin(theta_2 + theta_3) * L_3
  j_10 = math.cos(theta_1) * (math.cos(theta_2 + theta_3) * L_3 + \
                               math.cos(theta_2) * L_2 + L_1)
  j_11 = -math.sin(theta_1) * (math.sin(theta_2 + theta_3) * L_3 + \
                               math.sin(theta_2) * L_2)
  j_12 = -math.sin(theta_1) * math.sin(theta_2 + theta_3) * L_3
  j_20 = 0
  j_21 = -math.cos(theta_2 + theta_3) * L_3 - math.cos(theta_2) * L_2
  j_22 = -math.cos(theta_2 + theta_3) * L_3
  j_30 = 0
  j_31 = -math.sin(theta_1)
  j_32 = -math.sin(theta_1)
  j_40 = 0
  j_41 = math.cos(theta_1)
  j_42 = math.cos(theta_1)
  j_50 = 1
  j_51 = 0
  j_52 = 0
  jacobian = np.array([[j_00, j_01, j_02], [j_10, j_11, j_12], [j_20, j_21, j_22],\
                      [j_30, j_31, j_32], [j_40, j_41, j_42], [j_50, j_51, j_52]])

  return jacobian

def pseudoinverse(jacobian):
    u, s, vh = np.linalg.svd(jacobian)
    s = np.diag(s)
    zeros = np.zeros((3, 3))
    s = np.concatenate((s, zeros), axis=1)
    for i in range(len(s)):
      for j in range(len(s[0])):
        if s[i][j] != 0:
          s[i][j] = s[i][j]/(s[i][j] ** 2 + lambda_sq)
    return vh.T @ s @ u.T

def calc_error(fk):
    fk = fk[:-1]
    o_k = fk[:, [3]]
    x_k = fk[:, [0]]
    y_k = fk[:, [1]]
    z_k = fk[:, [2]]
    delta_o = o_d - o_k
    delta_theta = (1/2) * (np.cross(x_k.T, x_d.T) + np.cross(y_k.T, y_d.T) + np.cross(z_k.T, z_d.T))
    delta = np.stack((delta_o, delta_theta.T)).reshape((6, 1))
    return delta

@measure_time()
def newtons():
    theta = np.array([[0], [0], [0]])
    e_norm = np.inf
    count = 0
    last = np.array([[0], [0], [0]])
    norm = 0
    while e_norm > 0.4:
        fk = forward_kinematics(theta[0][0], theta[1][0], theta[2][0])
        o_k = fk[:, [3]]
        o_k = o_k[:-1]
        jacob = jacobian(theta[0], theta[1], theta[2])
        pseudo = pseudoinverse(jacob)
        error = calc_error(fk)
        theta = theta + (pseudo @ error)
        e_norm = np.linalg.norm(error)
        count += 1
        norm = (np.linalg.norm(o_k - last) + (norm * (count - 1))) / count 
        last = o_k

    final_pos = forward_kinematics(theta[0][0], theta[1][0], theta[2][0])
    print(final_pos)
    print(e_norm)
    print(count)
    print(norm)

newtons()

@measure_time()
def gd():
    theta = np.array([[0], [0], [0]])
    e_norm = np.inf
    count = 0
    last = np.array([[0], [0], [0]])
    norm = 0
    while e_norm > 0.4:
        fk = forward_kinematics(theta[0][0], theta[1][0], theta[2][0])
        o_k = fk[:, [3]]
        o_k = o_k[:-1]
        jacob = jacobian(theta[0], theta[1], theta[2])
        error = calc_error(fk)
        theta = theta + (jacob.T @ error) * alpha
        e_norm = np.linalg.norm(error)
        count += 1
        norm = (np.linalg.norm(o_k - last) + (norm * (count - 1))) / count
        last = o_k

    final_pos = forward_kinematics(theta[0][0], theta[1][0], theta[2][0])
    print(final_pos)
    print(e_norm)
    print(count)
    print(norm)

gd()

